---
output:
  reprex::reprex_document:
    venue: "gh"
    advertise: FALSE
    session_info: TRUE
    style: TRUE
    comment: "#;-)"
    tidyverse_quiet: FALSE
    std_out_err: TRUE
knit: reprex::reprex_render
---

This template demonstrates many of the bells and whistles of the `reprex::reprex_document()` output format. The YAML sets many options to non-default values, such as using `#;-)` as the comment in front of output.

## Code style

Since `style` is `TRUE`, this difficult-to-read code (look at the `.Rmd` source file) will be restyled according to the Tidyverse style guide when it's rendered. Whitespace rationing is not in effect!

```{r}
x=1;y=2;z=x+y;z
```

## Quiet tidyverse

The tidyverse meta-package is quite chatty at startup, which can be very useful in exploratory, interactive work. It is often less useful in a reprex, so by default, we suppress this.

However, when `tidyverse_quiet` is `FALSE`, the rendered result will include a tidyverse startup message about package versions and function masking.

```{r, eval = requireNamespace("tidyverse", quietly = TRUE)}
library(tidyverse)
```

## Chunks in languages other than R

Remember: knitr supports many other languages than R, so you can reprex bits of code in Python, Ruby, Julia, C++, SQL, and more. Note that, in many cases, this still requires that you have the relevant external interpreter installed.

Let's try Python!

```{python, eval = Sys.which("python") != "", python.reticulate = requireNamespace("reticulate", quietly = TRUE)}
x = 'hello, python world!'
print(x.split(' '))
```

And bash!

```{bash, eval = Sys.which("bash") != ""}
echo "Hello Bash!";
pwd;
ls | head;
```

Write a function in C++, use Rcpp to wrap it and ...

```{Rcpp, eval = requireNamespace("Rcpp", quietly = TRUE)}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}
```

then immediately call your C++ function from R!

```{r, eval = requireNamespace("Rcpp", quietly = TRUE)}
timesTwo(1:4)
```

## Standard output and error

Some output that you see in an interactive session is not actually captured by rmarkdown, when that same code is executed in the context of an `.Rmd` document. When `std_out_err` is `TRUE`, `reprex::reprex_render()` uses a feature of `callr:r()` to capture such output and then injects it into the rendered result.

Look for this output in a special section of the rendered document (and notice that it does not appear right here).

```{r}
system2("echo", args = "Output that would normally be lost")
```

## Session info

Because `session_info` is `TRUE`, the rendered result includes session info, even though no such code is included here in the source document. 



# Task 0

Clean up the data and prepare for DE analysis with edgeR
```{r load-packages echo=FALSE}

##### Checks for the required packages, install if missing #####

need <- c("readr","dplyr","tibble","stringr","ggplot2","limma","edgeR")
have <- rownames(installed.packages())
if (!"limma" %in% have || !"edgeR" %in% have) {
  if (!requireNamespace("BiocManager", quietly=TRUE)) install.packages("BiocManager")
  BiocManager::install(setdiff(c("limma","edgeR"), have), ask=FALSE)
}
inst <- setdiff(need, have); if (length(inst)) install.packages(inst)

library(readr); library(dplyr); library(tibble); library(stringr)
library(limma); library(edgeR); library(ggplot2)

```

```{r load-data echo=FALSE}
## Load raw data path, adjust as needed
datafile_path <- "C:/Users/Axis3/Github Repos/UniWork/IFN646/Project/Data/GSE159717_rnaseq_deseq_5dpi_counts_raw.tsv"

df <- read_tsv(datafile_path, show_col_types = FALSE)

# Count columns start with S_
count_cols <- grep("^S_", names(df), value = TRUE)

# Counts matrix (genes x samples)
cts <- df %>%
  select(gene_id, all_of(count_cols)) %>%
  column_to_rownames("gene_id") %>%
  as.matrix()
mode(cts) <- "integer"

# Sample metadata parsed from column names
samples <- tibble(sample = count_cols) %>%
  mutate(
    subject   = str_extract(sample, "^S_\\d+"), # subject (per Slack, means experiment each with replicates)
    treatment = str_extract(sample, "(?i)mock|SARS|Rem"), # treatment (case insensitive)
    time      = str_extract(sample, "\\d+dpi"), # timepoint (days post infection) - Not used
    run       = str_extract(sample, "S\\d+$") # sequencing run - Not used
  ) %>%
  mutate( ### factorise the variables and relabel conditions
    treatment = factor(treatment, levels = c("mock","SARS","Rem")),
    subject   = factor(subject),
    condition = factor(ifelse(tolower(treatment)=="sars","COVID",
                       ifelse(tolower(treatment)=="mock","Control","Other")),
                       levels = c("Control","COVID","Other"))
  )

stopifnot(all(colnames(cts) == samples$sample))
cat(sprintf("Genes: %d | Samples: %d\n", nrow(cts), ncol(cts)))
samples
```

we're starting with ~60,000 genes, but only 6 samples.
Two of these samples are treated, so for our purpose (effect of COVID on gene expression) we will focus on the contrast between SARS vs mock (control).

```{r filter-genes echo=FALSE}

# base filter, dropping all below 10, didn't help much. Too much noise.

# changing to protein-coding + filterByExpr from edgeR increases power

# Filter to protein-coding genes, then expression-aware filter
pc_ids <- df %>% dplyr::filter(gene_biotype == "protein_coding") %>% pull(gene_id)
cts_pc <- cts[rownames(cts) %in% pc_ids, , drop = FALSE]

# design we'll re-use later
design <- model.matrix(~ subject + treatment, data = samples)
design_simple <- model.matrix(~ treatment, data = samples)

# edgeR’s filterByExpr keeps genes with enough counts given your design/groups
keep <- edgeR::filterByExpr(cts_pc, design = design)
cts  <- cts_pc[keep, , drop = FALSE]

cat(sprintf("Kept %d genes after PC + filterByExpr\n", nrow(cts)))
colnames(design)

```

```{r validate-design echo=FALSE}
y <- cpm(DGEList(cts), log=TRUE, prior.count=1)

# SARS - mock per donor
diff_S2 <- y[, "S_2_SARS_5dpi_S70003"] - y[, "S_2_mock_5dpi_S70002"]
diff_S3 <- y[, "S_3_SARS_5dpi_S69996"] - y[, "S_3_mock_5dpi_S69997"]

# Agreement across donors (should cluster along y=x)
plot(diff_S2, diff_S3, pch=16, cex=0.4,
     xlab="log2FC (S_2: SARS - mock)", ylab="log2FC (S_3: SARS - mock)")
abline(0,1,lty=2,col="grey40")
cor(diff_S2, diff_S3, use="complete.obs")
```

``` {r paired echo=FALSE}
design_paired <- model.matrix(~ subject + treatment, data=samples)
v_p <- voomWithQualityWeights(cts, design_paired, plot=FALSE)
fit_p <- eBayes(lmFit(v_p, design_paired), robust=TRUE, trend=TRUE)
tt_p  <- topTreat(fit_p, coef="treatmentSARS", lfc=1, number=Inf)
```

```{r unpaired echo=FALSE}
design_unp <- model.matrix(~ treatment, data=samples)
v_u <- voomWithQualityWeights(cts, design_unp, plot=FALSE)
fit_u <- eBayes(lmFit(v_u, design_unp), robust=TRUE, trend=TRUE)
tt_u  <- topTreat(fit_u, coef="treatmentSARS", lfc=1, number=Inf)
```

```{r paired-vs-unpaired echo=FALSE}
sum(tt_p$adj.P.Val < 0.1); sum(tt_u$adj.P.Val < 0.1)  # rough counts
```

``` {r check-differences echo=FALSE}
# Focus on genes that change in at least one donor (|log2FC| >= 1)
sel <- (abs(diff_S2) >= 1) | (abs(diff_S3) >= 1)

cor_all  <- cor(diff_S2, diff_S3, use="complete.obs")                 # your –0.016
cor_big  <- cor(diff_S2[sel], diff_S3[sel], use="complete.obs")       # should we see agreement among big changes?
agree_big <- mean(sign(diff_S2[sel]) == sign(diff_S3[sel]), na.rm=TRUE)

c(cor_all = cor_all, cor_big = cor_big, prop_same_sign_big = agree_big)
```

``` {r check-for-sample-bias echo=FALSE}
v_qw <- limma::voomWithQualityWeights(cts, design, plot = FALSE)
sample_weights <- colMeans(v_qw$weights)
sample_weights
```

``` {r check-fisher-results echo=FALSE}
per_donor_fc <- tibble(
  gene = rownames(cts),
  log2FC_S2 = diff_S2,
  log2FC_S3 = diff_S3
)

fisher_hits <- consensus %>%
  filter(FDR_fisher < 0.10, agree_dir, abs(mean_logFC) >= 0.58) %>%
  arrange(FDR_fisher) %>%
  left_join(per_donor_fc, by = "gene") %>%
  select(gene, mean_logFC, FDR_fisher, log2FC_S2, log2FC_S3) %>%
  head(10)

fisher_hits
```

Essentially per donor aggreement is random - a coin flip.

one sample looks weaker.

This is hammering the limma-treat results (two donors that dont agree + effect size + BH). Fisher helps because both tools still see consistent evidence for a small subset of genes (and we required them to agree in direction + effect size)

``` {r sample-weight-check echo=FALSE}
## Which sample is down-weighted?
sw <- tibble(sample = samples$sample,
             subject = samples$subject,
             ## treatment only SARS and mock
             treatment = samples$treatment[samples$treatment %in% c("mock","SARS")],
             weight = as.numeric(sample_weights)) %>%
      arrange(weight)
sw  # lowest weight = most suspect
```

``` {r plot-disagreement echo=FALSE}
ggplot(sw, aes(x = reorder(sample, weight), y = weight, fill = treatment)) +
  geom_col() + coord_flip() +
  labs(title="voom sample weights (higher = cleaner)", x="", y="weight") +
  theme_minimal()
```

```{r fisher-sanity echo=FALSE}
fisher_hits <- consensus %>%
  filter(FDR_fisher < 0.10, agree_dir, abs(mean_logFC) >= 0.58) %>%
  arrange(FDR_fisher) %>%
  left_join(per_donor_fc, by = "gene") %>%
  select(gene, mean_logFC, FDR_fisher, log2FC_S2, log2FC_S3)
fisher_hits %>% head(10)
```

## Limma voom

Limma voom is an option for one of the DE tools. It is fast, stable, and powerful for small-sample RNA-seq.

```{r stablised-voom echo=FALSE}
# Quality-weighted voom + limma; keeps all 3 groups, tests SARS vs mock
v_qw <- voomWithQualityWeights(cts, design, plot = TRUE)   # draws mean-variance + sample weights
fit  <- eBayes(lmFit(v_qw, design), robust = TRUE, trend = TRUE)

# SARS vs mock (baseline = mock)
tt_SARS_vs_mock <- topTable(fit, coef = "treatmentSARS", number = Inf)

# Minimum effect: |log2FC| >= 1 (2x)
fit_treat     <- treat(fit, lfc = 1)
tt_treat_SARS <- topTreat(fit_treat, coef = "treatmentSARS", number = Inf)

# quick sanity: how many pass?
sum(tt_treat_SARS$adj.P.Val < 0.05 & abs(tt_treat_SARS$logFC) >= 1)


```

After running it though, there are no significant genes at 5% FDR and 2x fold-change. This is likely due to the small sample size (n=2 per group)
```{r relaxed-voom-fallback echo=FALSE}
# RELAXED (1.5x) – only if needed
fit_treat_rel     <- treat(fit, lfc = 0.58)
tt_treat_SARS_rel <- topTreat(fit_treat_rel, coef = "treatmentSARS", number = Inf)

sum(tt_treat_SARS_rel$adj.P.Val < 0.05 & abs(tt_treat_SARS_rel$logFC) >= 0.58)
```

```{r head-limma echo=FALSE}
head(tt_SARS_vs_mock)
head(tt_treat_SARS)
```

## Keep all of them, but only contrast COVID vs Control
--- Quick guide

LogFC - > Log2 Fold Change (SARS vs mock). Positive = up in SARS, Negative = down in SARS. e.g. 0.66 = 1.6x higher, -0.66 = 1.6x lower than Control.

AveExpr - > Average log2 expression across all samples (transformed CPM). Larger = more highly expressed.

t - > Moderated t-statistic (size of change relative to its variability after limma shrinks the variance)

P.Value - > Raw p-value (unadjusted)

adj.P.Val - > Adjusted p-value (Benjamini-Hochberg FDR correction for multiple testing). Use for significance thresholding.

In the first table also have B
B - > log-odds that the gene is DE (higher = more likely DE)




## EdgeR Variant

```{r edge-R-setup echo=FALSE}

dge <- DGEList(cts)
dge <- calcNormFactors(dge, method="TMM")
dge <- estimateDisp(dge, design, robust = TRUE)
qlf <- glmQLFit(dge, design, robust = TRUE)

coef_idx <- match("treatmentSARS", colnames(design))
# Test |log2FC| >= 1 (same as limma-treat above)
qlt_treat <- glmTreat(qlf, coef = coef_idx, lfc = 1)

edgeR_res <- topTags(qlt_treat, n = Inf)$table %>%
  rownames_to_column("gene") %>%
  transmute(gene,
            logFC_edgeR = logFC,
            p_edgeR     = PValue,
            FDR_edgeR   = FDR)

head(edgeR_res)


```

## Check for consensus between limma-voom and edgeR

```{r compare-limma-edger echo=FALSE}
limma_res <- tt_treat_SARS %>%
  rownames_to_column("gene") %>%
  transmute(gene,
            logFC_limma = logFC,
            p_limma     = P.Value,
            FDR_limma   = adj.P.Val)

consensus <- inner_join(limma_res, edgeR_res, by = "gene") %>%
  mutate(
    agree_dir        = sign(logFC_limma) == sign(logFC_edgeR),
    pass_limma       = FDR_limma < 0.05 & abs(logFC_limma) >= 1, ## relaxed to 5% FDR for consensus
    pass_edgeR       = FDR_edgeR < 0.05 & abs(logFC_edgeR) >= 1, ## relaxed to 5% FDR for consensus
    consensus_strict = pass_limma & pass_edgeR & agree_dir,
    mean_logFC       = (logFC_limma + logFC_edgeR) / 2,
    # Fisher combine for extra power; still require direction agreement
    p_fisher   = pchisq(-2 * (log(p_limma) + log(p_edgeR)), df = 4, lower.tail = FALSE),
    FDR_fisher = p.adjust(p_fisher, method = "BH"),
    CRISPR_action = ifelse(mean_logFC < 0, "CRISPRa (activate)", "CRISPRi (repress)")
  )

consensus %>%
  summarise(
    n = n(),
    pass_limma = sum(pass_limma),
    pass_edgeR = sum(pass_edgeR),
    agree_dir  = sum(agree_dir),
    strict     = sum(consensus_strict),
    fisher_5   = sum(FDR_fisher < 0.05 & abs(mean_logFC) >= 1 & agree_dir),
    fisher_10  = sum(FDR_fisher < 0.10 & abs(mean_logFC) >= 0.58 & agree_dir)
  )
```

```{r head-consensus echo=FALSE}
head(consensus %>% arrange(FDR_limma + FDR_edgeR))
```

```{r check-consensus_strict echo=FALSE}
consensus %>%
  summarise(
    n = n(),
    pass_limma = sum(FDR_limma < 0.05 & abs(logFC_limma) >= 1),
    pass_edgeR = sum(FDR_edgeR < 0.05 & abs(logFC_edgeR) >= 1),
    agree_dir  = sum(agree_dir),
    strict     = sum(consensus_strict)
  )
```

``` {r export echo=FALSE}
consensus %>%
  filter(consensus_strict) %>%
  select(gene, mean_logFC, FDR_limma, FDR_edgeR, CRISPR_action) %>%
  arrange(FDR_limma + FDR_edgeR) %>%
  write_csv("CRISPR_target_shortlist.csv")

# Fisher-based (exploratory): more power, still effect-size + direction
consensus %>%
  filter(FDR_fisher < 0.10, abs(mean_logFC) >= 0.58, agree_dir) %>%
  select(gene, mean_logFC, FDR_fisher, CRISPR_action) %>%
  arrange(FDR_fisher) %>%
  write_csv("CRISPR_target_shortlist_RELAXED.csv")

# Save full tables for marking/repro
write_csv(tt_SARS_vs_mock %>% rownames_to_column("gene"), "DE_limma_SARS_vs_mock.csv")
write_csv(tt_treat_SARS  %>% rownames_to_column("gene"), "DE_limma_treat_SARS_vs_mock.csv")
write_csv(edgeR_res, "DE_edgeR_treat_SARS_vs_mock.csv")
write_csv(consensus, "DE_consensus_limmaTreat_edgeR_treat.csv")
```

```{r results-sanity echo=FALSE}
# How many pass each tool individually?
sum(tt_treat_SARS$adj.P.Val < 0.05 & abs(tt_treat_SARS$logFC) >= 1)   # limma-treat strict
sum(edgeR_res$FDR_edgeR < 0.05 & abs(edgeR_res$logFC_edgeR) >= 1)     # edgeR glmTreat strict

# After Fisher combine (consensus table):
consensus %>%
  summarise(
    m = n(),
    strict = sum(FDR_limma < 0.05 & FDR_edgeR < 0.05 & abs(logFC_limma)>=1 & abs(logFC_edgeR)>=1 & agree_dir),
    relaxed = sum(FDR_fisher < 0.10 & abs(mean_logFC)>=0.58 & agree_dir)
  )
```

### SIDEQUEST - Explain why the consensus strict is so low and why the relaxed gets some targets
```{r bh-explore echo=FALSE}
bh_report <- function(p, q = c(0.05, 0.10), top = 15, label = "p-values") {
  p <- p[is.finite(p) & !is.na(p)]
  m <- length(p); stopifnot(m > 0)

  p_sorted <- sort(p)
  k <- seq_len(m); x <- k / m

  # Build a tidy table of cutoffs and pass/fail
  df <- tibble(rank = k, x = x, p_sorted = p_sorted)
  for (qq in q) {
    df[[paste0("cutoff_q", sprintf("%02d", qq*100))]] <- x * qq
    df[[paste0("pass_q",   sprintf("%02d", qq*100))]] <- p_sorted <= x * qq
  }

  # Critical k* and #discoveries via BH (also sanity-check with p.adjust)
  k_star <- sapply(q, function(qq) max(c(0, which(p_sorted <= x * qq))))
  names(k_star) <- paste0("q", sprintf("%02d", q*100))
  disc_adj <- sapply(q, function(qq) sum(p.adjust(p_sorted, "BH") < qq))
  names(disc_adj) <- paste0("adj<", sprintf("%02d", q*100))

  # Plot: sorted p with exact BH curves (computed, not abline) on log-y
  cut_long <- df %>%
    select(rank, x, starts_with("cutoff_q")) %>%
    pivot_longer(starts_with("cutoff_q"),
                 names_to = "q", values_to = "cutoff") %>%
    mutate(q = gsub("cutoff_q", "q = ", q))

  g <- ggplot(df, aes(x = x, y = p_sorted)) +
    geom_point(size = 0.6, alpha = 0.6) +
    geom_line(data = cut_long, aes(y = cutoff, linetype = q), linewidth = 0.6) +
    scale_y_log10() +
    labs(
      title = "BH step-up: sorted p vs BH cutoffs",
      subtitle = paste0("m = ", m, "  |  ", label),
      x = "rank / m", y = "sorted p-value (log10)"
    ) +
    theme_minimal()

  list(
    top_table = head(df, top),
    k_star = k_star,
    n_discoveries = disc_adj,
    m = m,
    plot = g
  )
}
```

``` {r bh-limma echo=FALSE}
bh_limma <- bh_report(tt_treat_SARS$P.Value, q = c(0.05, 0.10),
                      top = 15, label = "limma-treat (lfc ≥ 1)")
bh_limma$top_table
bh_limma$k_star
bh_limma$n_discoveries
bh_limma$plot
```

``` {r bh-fisher echo=FALSE}
bh_fisher <- bh_report(consensus$p_fisher, q = c(0.05, 0.10),
                       top = 15, label = "Fisher-combined (limma+edgeR)")
bh_fisher$top_table
bh_fisher$k_star
bh_fisher$n_discoveries
bh_fisher$plot
```


``` {r bh-headline echo=FALSE}
cat(sprintf("BH critical ranks — limma-treat: q=0.05→%d, q=0.10→%d; discoveries via p.adjust: %s\n",
            bh_limma$k_star["q05"], bh_limma$k_star["q10"],
            paste(names(bh_limma$n_discoveries), bh_limma$n_discoveries, collapse=", ")))

cat(sprintf("BH critical ranks — Fisher: q=0.05→%d, q=0.10→%d; discoveries via p.adjust: %s\n",
            bh_fisher$k_star["q05"], bh_fisher$k_star["q10"],
            paste(names(bh_fisher$n_discoveries), bh_fisher$n_discoveries, collapse=", ")))
```

## Visualise results

```{r MDS-plot}
# MDS (by Control/COVID labelling)
cols <- c(Control="grey40", COVID="firebrick", Other="steelblue")
plotMDS(dge, labels = samples$condition, col = cols[as.character(samples$condition)])
legend("topright", legend=none, col=cols, pch=16, bty="n")

```



```{r md-plot echo=FALSE}
# MD plot (edgeR QL test)
plotMD(qlt, status = decideTestsDGE(qlt), main = "MD plot (edgeR QL)")
abline(h = c(-1,1), col="darkgrey", lty=2)

```

``` {r volcano-plot echo=FALSE}
# Volcano (limma-treat)
vol <- transform(limma_res, negLog10P = -log10(p_limma), sig = FDR_limma < 0.05 & abs(logFC_limma) >= 1)
plot(vol$logFC_limma, vol$negLog10P,
     pch=20, cex=0.6, col=ifelse(vol$sig,"firebrick","grey70"),
     xlab="log2 FC (SARS vs mock, limma-treat)", ylab="-log10 p",
     main="Volcano (limma-treat)")
abline(v=c(-1,1), lty=2, col="darkgrey"); abline(h=-log10(0.05), lty=2, col="darkgrey")
```


## Save results for later

```{r save-results echo=FALSE}
write_csv(samples, "samples_parsed.csv")
write_tsv(as_tibble(cts, rownames = "gene_id"), "counts_filtered.tsv")

write_csv(tt_SARS_vs_mock %>% rownames_to_column("gene"), "DE_limma_SARS_vs_mock.csv")
write_csv(tt_treat_SARS  %>% rownames_to_column("gene"), "DE_limma_treat_SARS_vs_mock.csv")
write_csv(edgeR_res, "DE_edgeRQL_SARS_vs_mock.csv")
write_csv(consensus, "DE_consensus_limmaTreat_edgeRQL.csv")

# Strict consensus shortlist
consensus %>%
  filter(consensus_strict) %>%
  select(gene, mean_logFC, FDR_limma, FDR_edgeR, CRISPR_action) %>%
  arrange(FDR_limma + FDR_edgeR) %>%
  write_csv("CRISPR_target_shortlist.csv")
```